{0 Wordpress}

{e WordPress} is a free and open-source content management system
(CMS) written in OCaml. In other words, {e Wordpress} is a static blog
generator written in OCaml. And yes, another one!

The objective of the project is mainly to learn how to use OCaml (and
to discover its ecosystem). It is therefore likely that some parts of
the code are not idiomatic and please do not hesitate to tell me or to
contribute. In addition, it was an opportunity to experiment with the
ergonomics of the {{:https://github.com/xvw/preface} Preface} library
and to provide it with slightly less academic examples.

When thinking about how to compute file dependencies, I had initially
settled on the idea of using a comonad transformation ([TracedT]) but
then I remembered the paper
{{:http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf} Generalising
Monads to Arrows}, which describes the construction of static and
dynamic parsers which seemed relevant to capturing dependencies.

On the other hand, I was perfectly aware of the existence of
{{:https://jaspervdj.be/hakyll/} Hakyll}, an excellent "static blog
generator, generator" (notably used by my friend
{{:https://xvw.github.io} xvw}). But in my understanding of the
definition flow of a generator (at user level, I have never observed
the source code), the document construction routine was monadic.  days
ago, {{:https://github.com/mspwn} msp} pointed out to me that Hakyll,
prior to version 4, used dependency capture logic incredibly similar
to that of {e WordPress}, funny! Hakyll decided to use a monadic
construction to simplify the DSL. Maybe I'll come to the same
conclusions when I have to maintain a blog with complicated
construction rules, I'll totally replace my API and in that case, I'll
probably take inspiration from the work done on Hakyll. But for the
moment I'm quite happy with it.

{1 Full Documentation}

The full API can be {{:Wordpress/index.html} found here}

{1 Alternatives}

As my main motivation is to discover OCaml while having a tool to
build my personal page, it is likely that {e WordPress} is absolutely
not usable for anyone but me, so here are some alternatives.

- {{:https://www.good-eris.net/stog/} Stog} is a static web site
  compiler. It is able to handle blog posts as well as regular pages
  or any XML document in general
  
- {{:https://github.com/Armael/stone} Stone} is a static
  website generator: it takes a template, a css stylesheet, the
  content itself written in a high-level formatting syntax, and
  generates the corresponding html pages
  
- {{:https://github.com/patricoferris/sesame} Sesame} is a library of
  tools for building smaller, greener, less resource intensive and
  more accessible website and blogs inspired by Low Tech Magazine
  
- {{:https://soupault.app/} Soupault} is a tool that helps you create
  and manage static websites

If for some obscure reason you would like to be included in this
list...  {{:https://github.com/xhtmlboi/wordpress/issues} drop me a
line}

{1 Credits}

{e WordPress} makes use of several libraries from the OCaml ecosystem,
you can find an exhaustive list in the
{{:https://github.com/xhtmlboi/wordpress/blob/main/wordpress.opam}
Opam file} at the root of the project. For an exhaustive list of
contributors, I invite you to visit the
{{:https://github.com/xhtmlboi/wordpress} Github page} of the project.

{2 Tools}

I haven't written OCaml for a very long time and the very clear
progress of the ecosystem is very impressive!

- {{:https://ocaml.org} OCaml} (of course), I guess that the project
  was mainly developped using [OCaml 4.12]
- {{:https://dune.build/} Dune}, {{:https://opam.ocaml.org} OPAM} (and
  {{:https://www.gnu.org/software/make/} Gnu Make} as build-system
- {{:https://github.com/ocaml/odoc} odoc} as a documetation parser and
  generator

{2 Libraries}

Even though the libraries are part of the tooling, I was very pleased
to quickly discover a collection of well documented libraries with a
pleasant user experience. Each of these libraries also has
dependencies which I invite you to consult (or apply [ocamldep]) to
get a full understanding of what made this project possible.

- {{:https://github.com/xvw/preface} Preface} as a complement to the
  standard library and as an effects manager and abstraction provider.
  As this project was started to test the usability of the library, a
  very large part of the code is based on this library.
- {{:https://github.com/mirage/alcotest} Alcotest} is a very funny
  name for a very nice unit test library
- {{:https://github.com/ocaml/omd} omd} Markdown is a fairly common
  format for writing on the internet. Fortunately, OCaml has an
  excellent [txt] -> [markdown] conversion library
- {{:https://github.com/avsm/ocaml-yaml} ocaml-yaml} by default, I use
  [Yaml] to describe metadata
- {{:https://github.com/rgrinberg/ocaml-mustache} ocaml-mustache} by
  default, I use [Mustache] for templating


{1 Tutorial}

{e Wordpress} is slightly different from many tools that statically
build web pages. Instead of imposing a template to follow, WordPress
is a {b library} and it is up to the user to compose their generator.
This approach does, unfortunately, make the rapid bootstrapping of a
blog a little more complicated but it does allow the user more freedom
in how they want to organise and generate their page collection.

In this little tutorial, I'll show you several ways to build pages
with {e WordPress}, in peace and quiet. But the tutorial assumes that
you use (and understand) {{:http://opam.ocaml.org/}OPAM} and
{{:https://dune.build/}Dune}. So I won't dwell on how to
install {e WordPress} (using a [pin]) and sometimes I'll use Preface.

This tutorial is very prescriptive and essentially uses the default behaviours
of {e Wordpress}. However, keep in mind that while the library makes arbitrary
decisions to facilitate bootstrapping a project, you can build your own build
rules based on the libraries of your choice.

{2 As a simple template engine}

When designing static sites, it is sometimes common to only want a
list of pages that respect the same template. Writing all the content
in HTML and copying/pasting the templates into each document works
fine, but when you want to modify the template, you have to do it...
for all the pages... what a hell! As a first tutorial, I suggest you
discover how to separate the templates from the content.

Here is the file tree I propose:

{[
./
templates/
pages/
bin/
]}

In [templates/] we will place our templates. For the purposes of the example,
an [header] and a [footer], and in [pages/] we will place our pages.
For example [index.html] for the home page, [project.html] for a list of
projects and [about.html] to describe the role of the website.
[bin] will be used to host the source code of our site generator.
Quite common in short.

{3 Setting up the project}

Create a [bin/dune] and [bin/my_site.ml] file (if you want to name the binary
that will be used to create a site [my_site.exe]) and define the dune file
as such:

{[
(executable
 (name my_site)
 (promote (until-clean))
 (libraries wordpress))
]}

Nothing very clever, we just say we want an executable and that will have
{e WordPress} as a dependency... it makes sense!

{3 Defining some pages and templates}

I offer you high quality HTML code for the templates, a header and a footer.
The idea is to pipe the header, the page and the footer.

Here is an example of header. As you can see, I'm pretty experimented with
HTML.

{[
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>My website lol</title>
</head>
<body>
    <h1>My Website</h1>
    <ul>
        <!-- "A powerful menu"  -->
        <li><a href="index.html">Home</a></li>
        <li><a href="projects.html">Projects</a></li>
        <li><a href="about.html">About</a> </li>
    </ul>
    <hr>
    <main>
]}

Let's create a footer with the ambition of our header!


{[
    </main>
    <hr>
    copyright <strong>Myself</strong>
  </body>
</html>
]}

You can now create several pages, for example, [index.html],
[project.html] and [about.html] with arbitrary content.

{3 Defining the generator}

Let's go back to our [my_site.ml] file to create our generator!

{[
open Wordpress

let destination = "_build"

let () =
  print_endline "Hello"
]}

First, let's define where we want to generate our site. I chose
the [_build] directory, so I don't have to modify the [.gitignore]
of the project.

To create a page, the process is quite simple. We will browse all
the files in the [pages] directory and for each file, we will
create a file with the same name in our destination directory which
will read the [header.html] template, piping its content with the file
we are reading and piping it with the [footer.html] template.

Most of the functions we will use are in the {!module:Wordpress.Build} module.

{[
open Wordpress

let destination = "_build"

let task =
  process_files ["pages/"] (with_extension "html") (fun file ->
      let target = basename file |> into destination in
      let open Build in
      create_file target (
        read_file "templates/header.html"
        >>> pipe_content file
        >>> pipe_content "templates/footer.html")
    )

let () =
  print_endline "Hello"

]}

The API tries to be as clear as possible. The [process_files] function
takes a list of directories as an argument and filters the entries with
a predicate. Here, the files must end in [.html]. Then, for each file,
we will create an image in our destination, read the header, read the
browsed file and pipe it with the header content, read the footer and pipe
it with the previous content.

Now you have to run the program described above. Nothing could be easier,
we can use {!val:Wordpress.execute}. (It is possible to provide its own
execution function, for that I refer you to
{{:https://github.com/xvw/preface/blob/master/guides/freer_effect_handling.md}
    the guide on the Preface effect handlers}).

{[
open Wordpress

let destination = "_build"

let task =
  process_files ["pages/"] (with_extension "html") (fun file ->
      let target = basename file |> into destination in
      let open Build in
      create_file target (
        read_file "templates/header.html"
        >>> pipe_content file
        >>> pipe_content "templates/footer.html")
    )

let () =
  execute task
]}

That's it! You have your first template engine that you can try
out and that replaces the PHP includes!

{3 Adding the generator as a dependency}

The functions in the {!module:Wordpress.Build} module capture their
dependencies and compositions, with the [>>>] operator merging them.
In our example, each page to be built will have as dependencies
[templates/header.html], [templates/footer.html] and the page in the
[pages] directory being observed. This means that each page will be
rebuilt {e if and only} if necessary.

On the other hand, if the generator is ever recompiled, which could have
the effect of completely changing our site, we would also like to be able
to consider that a file has to be regenerated. Fortunately the
{!val:Wordpress.Build.watch} function allows us to add a file to the
dependencies without reading it, so we can modify our [task] in this way:

{[
open Wordpress

let destination = "_build"
let track_binary_update = Build.watch Sys.argv.(0)

let task =
  process_files [ "pages/" ] (with_extension "html") (fun file ->
      let target = basename file |> into destination in
      let open Build in
      create_file
        target
        (track_binary_update
        >>> read_file "templates/header.html"
        >>> pipe_content file
        >>> pipe_content "templates/footer.html"))
;;

let () = execute task
]}

Now, every time the generator is recompiled, the pages will have to be rebuilt!

{2 Using a proper templating strategy}

At the moment we have cheated by splitting our layout into two files but this is
not usually done! We would like to be able to inject the content directly into
a file containing the entire layout like this, in [templates/layout.html]:

{[
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>My website lol</title>
</head>
<body>
    <h1>My Website</h1>
    <ul>
        <!-- "A powerful menu"  -->
        <li><a href="index.html">Home</a></li>
        <li><a href="projects.html">Projects</a></li>
        <li><a href="about.html">About</a> </li>
    </ul>
    <hr>
    <main>
        {{{body}}}
    </main>
    <hr>
    copyright <strong>Myself</strong>
</body>
</html>
]}

By default, {e Wordpress} uses {{:https://mustache.github.io/}Mustach}
via the excellent {{:https://github.com/rgrinberg/ocaml-mustache} ocaml-mustache}
library to describe templates. The idea is to attempt to read a file and
its metadata and inject it into a template that is ready for the
metadata. I invite you to read the
{{:https://mustache.github.io/mustache.5.html}Mustach documentation}
to understand all that can be described.

{3 Applying a template}

Now we need to modify our generator so that it reads a file and injects it into
our template. The {!module:Wordpress.Metadata} module offers a structured
set of metadata. For the purposes of this tutorial, we will use
{!module:Wordpress.Metadata.Page} which does not impose much.
Indeed, it offers two optional fields: [Title] and [Description].

The modification in the generator to be made is that the file and its potential
metadata must be read using the {!val:Wordpress.Build.read_file_with_metadata}
function and then applied to the template using the
{!val:Wordpress.Build.apply_as_template} function. Both functions take a module
that describes how to parse/inject metadata.
Here we use {!module:Wordpress.Metadata.Page}.

{[

let task =
  process_files [ "pages/" ] (with_extension "html") (fun file ->
      let target = basename file |> into destination in
      let open Build in
      create_file
        target
        (track_binary_update
        >>> read_file_with_metadata (module Metadata.Page) file
        >>> apply_as_template (module Metadata.Page) "templates/layout.html"
        >>^ Stdlib.snd))
;;
]}

{!val:Wordpress.Build.read_file_with_metadata} and {!val:Wordpress.Build.apply_as_template}
return a pair with an option for the metadata and the file content. Fortunately,
the application of a template takes optional metadata as an argument but the
function will return the metadata unchanged and the contents of the template
application. So in the end, it is only necessary to keep the processed content,
hence the use of [>>^ Stdlib.snd] which allows a normal function to be applied as
an arrow.

Now we should have exactly the same site as before except that our layout is better
defined!

{3 Using Metadata}

At the moment we do not use the optional metadata at all. Which is a shame!
Let's see how to inject data into the pages to enrich the meaning of our pages!
By default, metadata is expressed in Yaml via the
{{:https://github.com/avsm/ocaml-yaml} ocaml-yaml} library and uses a
format similar to {{:https://jekyllrb.com/}Jekyll}. Let's add metadata to our pages.
For example for [pages/about.html]:

{[
---
title: The famous about page
description: This page TALK ABOUT ME!
---
You are on the about page.
]}

And let's modify our template to display this metadata if it exists... or not:

{[
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>My website lol</title>
</head>
<body>
    <h1>My Website</h1>
    <ul>
        <!-- "A powerful menu"  -->
        <li><a href="index.html">Home</a></li>
        <li><a href="projects.html">Projects</a></li>
        <li><a href="about.html">About</a> </li>
    </ul>
    <hr>
    {{#title}}<h2>{{.}}</h2>{{/title}}
    {{#description}}<p>{{.}}</p>{{/description}}
    <main>
        {{{body}}}
    </main>
    <hr>
    copyright <strong>Myself</strong>
</body>
</html>
]}

The template modification uses the "conditional" syntax to display the title and
description only if the metadata is present. And yes, remember, the title and
description are optional!
